global !p
from snippet_helpers import *
endglobal

# TODO:
# Understand how this snippet works.
# Once you do, use your knowledge to improve `fu` in a non-autoloaded file.
# The cursor should automatically jump, so that we don't have to press Tab
# twice to jump to the arguments.

#     context "make_context(snip)"
#     post_jump "clean_first_placeholder(snip)"
#     snippet x "" bm
#     `!p jump_to_second_when_first_is_empty(snip)
#     `func (${1:blah}) $2() {
#     	$3
#     }
#     endsnippet

# ?: {{{1

snippet ?: "(test ? expr1 : expr2)" im
($1 ? $2 : $3)
endsnippet

# abbreviation {{{1

#                   ┌ if the 1st tabstop is empty, the interpolation should be too;
#                   │ we need to handle this special case,
#                   │ to avoid an error if we delete an inserted tabstop
#                   │ (because in this case `t[1][0]` won't exist)
#                   │
#                   │                    ┌ text of 1st placeholder $1
#                   ├────────────┐       ├──┐
#     !p snip.rv = '' if not t[1] else (t[1][0]).upper() + t[1][1:]
#                                             │                  ├┘
#                                             │                  └ remaining characters
#                                             └ first character

# Why do you use `getcmdpos()`?  Why not `getcmdline() is# '$1'`?{{{
#
# `getcmdpos()` is more reliable.
#
# Suppose we've written a command without our abbreviation.
# Then, we press `C-a` to move at the beginning of the line.
# Finally, we insert the abbreviation and press `SPC` or `Enter`.
#
# The command-line won't contain just the abbreviation, so this will fail:
#
#     getcmdline() is# 'lhs'
#
# But not this:
#
#     getcmdpos() ==# 4
#}}}
snippet abr "uppercase abbreviation on command-line" bm
cnorea  <buffer><expr>  ${1:lhs}  getcmdtype() is# ':' && getcmdpos() ==# `!p snip.rv = len(t[1]) + 1`
\\`!p snip.rv = ' '*(25 + len(t[1]))`?    '`!p snip.rv = '' if not t[1] else (t[1][0]).upper() + t[1][1:]`'
\\`!p snip.rv = ' '*(25 + len(t[1]))`:    '`!p snip.rv = t[1]`'
endsnippet

# autocmd {{{1

# Explanation of the mirror:{{{
#
#             ┌ look for a space followed by a star,
#             │ and capture it so that I can test whether the subpattern has been matched, via `?1`
#             │
#             │     ┌ OR, look for anything
#             ├───┐ ├┐
#         ${2/( \*)|.*/(?1:: \*)/}
#                       ├┘├┘├─┘
#                       │ │ └ otherwise, insert a space followed by a star
#                       │ │   (to leave the autocmd pattern unchanged)
#                       │ │
#                       │ └ replace its contents with nothing
#                       │   (SPC * SPC <buffer>  →  SPC <buffer>)
#                       │
#                       └ if the 1st capturing group is not empty (SPC *)
#}}}
# Also, from :h UltiSnips-replacement-string:{{{
#
# > Finally, the  replacement string can contain  conditional replacements
# > using the syntax (?123:foo:bar). This  reads as follows:
# >
# >     if the group 123 has matched, replace it with "foo", otherwise insert "bar"
# >
# > "bar"  is  optional  and  if   not  provided  defaults  to  the  empty
# > string. This feature is  very powerful. It allows you  to add OPTIONAL
# > text into snippets.
#}}}

pre_expand "capture_visual_content(snip)"
post_expand "trim_ws(snip)"
snippet au  "augroup ... autocmd block" bm
augroup ${1:test_sth}
	au!${2: * <buffer>}
	au ${3:BufWinEnter}${2/( \*)|.*/(?1:: \*)/} ${0:${VISUAL}}
augroup END
endsnippet

snippet auu  "one shot autocmd" bm
unlet! s:did_shoot
au ${1:Event1,Event2,...} $2`!p snip.rv = complete(t[2], ['*', '<buffer>'])` ++once
	\ if !get(s:, 'did_shoot', 0)
	\ |     let s:did_shoot = 1
	\ |     ${3:" do sth just once}
	\ | endif
endsnippet

# completion function (c-x c-u){{{1

snippet ccfu "Completion function for C-x C-u" Abm
let ${1:s:candidates} = ${2:[]}
fu! s:${3:complete_words}(findstart, base) abort
	if a:findstart
		return searchpos('${4:<}', 'bnW', line('.'))[1] - 1
	else
		return filter(copy($1), {_,v -> stridx(v, a:base) ==# 0})
	endif
endfu

${6:" make sure s:snr() is defined
}let &l:cfu = s:snr()..'$3'
$0
endsnippet

# Why not using  v =~ '^'.a:base  ?{{{2
#
# To filter the candidates, we could write this condition:
#
#      v =~ '^'.a:base
#
# But instead, we write:
#
#      filter(candidates, {_,v -> stridx(v, a:base) ==# 0})
#
# Because `a:base` could contain special characters.
# If there are, we don't want them to be interpreted by the regex engine.

# Is there a case-insensitive alternative?{{{2
#
# Yes:
#
#     return empty(a:base)
#         \ ?     candidates
#         \ :     filter(candidates, {_,v -> v[:strlen(a:base)-1] is? a:base})
#                                                                   │
#                                                                   └ ignore case
#
# Why treating the case where `a:base` is an empty string separately?
#
# If `a:base` is empty, the test will fail for all candidates, and the completion
# function will not return anything. I don't want that. I want all candidates.
# MWE:
#
#                        ┌─ ''
#                        │
#          v[:strlen(a:base)-1]
#        → v[:-1]
#        → v
#          != a:base ('')


# completion function (custom command) {{{1

# There's a very long string in the python interpolation.{{{
#
# You can split such a string in (here 4) consecutive strings to gain in readibility:
#
#     'let word_before_cursor = matchstr(a:cmdline, \'.*\s\zs-\S.*\%\'..a:pos..\'c\')\n'
#     '    let word_before_cursor = matchstr(word_before_cursor, \'\S*\s*$\')\n'
#     '\n'
#     '    if word_before_cursor =~# \'^-mode\s*\''
#
# They will be concatenated at compile time:
# https://stackoverflow.com/a/3346295/9780968
#}}}
snippet cfu "Completion function for a custom command" Abm
fu! s:${1:completion_function}(${3:${2:_}arglead}, ${4:_}cmdline, ${5:_}pos) abort
	$6`!p
snip.rv = complete(t[6], ['if a:cmdline =~# \'\m-mode\s\+\w*$\'',
'let word_before_cursor = matchstr(a:cmdline, \'.*\s\zs-\S.*\%\'..a:pos..\'c.\')\n'
'\n'
'    if word_before_cursor =~# \'^-mode\s*\S*$\''
])
`
		let ${7:modes} = [${8:'normal', 'visual', 'insert'}]
		return join($5, "\n")

	elseif ${9:empty(a:$3) || a:$3[0] is# '-'}
		let ${10:options} = [${11:'-option1', '-option2', '-mode'}]
		return join($10, "\n")
	endif

	return ''
endfu
$0
endsnippet

# conceal {{{1

# Don't change the priority of the match (`0`)!{{{
#
# https://github.com/vim/vim/issues/2185
#
# Update:
# This should be fixed by:
#
# https://github.com/vim/vim/commit/ab62c19ea034d76632bbbf4265a9fc17e7508541
#}}}
snippet conceal "conceal using `matchadd()`" bm
setl cocu=nc cole=3
call matchadd('Conceal', ${2:'${1:pat}'}, 0, -1, {'conceal': '${3:x}'})
$0
endsnippet

# command {{{1

# FIXME:{{{
# We need  to add  a tabstop, iff,  the user chooses  the public  function right
# after the 4th tabstop.
# We have the same issue in the `fu` snippet.
#
# Also, why does  the cursor jump when  we insert a comma right  after the third
# tabstop?
# Study the issue from these examples:
# ✔
#     foo $1`!p snip.rv = complete(t[1], ['a', 'b', 'c'])` bar
# ✘
#     foo ${1:bar$2`!p snip.rv = complete(t[2], ['a', 'b', 'c'])` baz}
#}}}
snippet com "command" bm
com! ${1:-bar }`!v
expand('%:p:h:t') is# 'ftplugin' ? '-buffer' : ''
`${2:-complete=custom$3`!p
snip.rv = complete(t[3], [',', 'list,'])
`$4`!p
snip.rv = complete(t[4], ['s:func', vim.eval("snippets#get_autoload_funcname()")])
` }${5:-nargs=$6`!p
snip.rv = complete(t[6], ['0', '1', '*', '?', '+'])
` }${7:-range=% }${8:Cmd} ${9:call s:${10:func}()}
endsnippet

# doautocmd User {{{1

snippet do "Create a hook to be able to register for callback" bm
if exists('#User#${1:PluginFuncPost}')
	doautocmd <nomodeline> User $1
endif
$0
endsnippet

# for {{{1

snippet ff "for loop" Abm
for ${1:i} in ${2:a_list}
	${0:${VISUAL}}
endfor
endsnippet

# function {{{1

# FIXME:
# Expand the snippet in an autoloaded file.
# A tabstop is missing.
# We need to add one, iff, the user chooses the public function,
# with a `#` sign.
# Why `post_expand`?{{{
#
# When the visual selection contains an  empty line, and our snippet inserts the
# `${VISUAL}` placeholder, UltiSnips inserts 4 spaces on the line.
# We need to trim it. The `m` option doesn't work.
# So, we use a python function invoked via a `post_expand` statement.
#}}}
pre_expand "capture_visual_content(snip)"
post_expand "trim_ws(snip)"
snippet fu "function definition" Abm
fu! $1`!p
snip.rv = complete(t[1], ['s:func', 'Func', vim.eval("snippets#get_autoload_funcname()")])
`($2) abort
	${0:${VISUAL}}
endfu
endsnippet

# guard {{{1

pre_expand "plugin_guard(snip)"
snippet gd "plugin guard" Abm
endsnippet

# if {{{1

snippet ii "if statement" Abm
if $1
	${2:${VISUAL}}
${5:${3:else}
	$4
}endif
$0
endsnippet

context "snip.last_placeholder and snip.last_placeholder.current_text == 'else'"
snippet e "elseif" A
elseif $1
	$2
${3:else}
endsnippet

# global !p
# def complete(t, opts):
#     if t:
#         opts = [ m for m in opts if m.startswith(t) ]
#     if len(opts) == 1:
#         return opts[0][len(t):]
#     elif len(opts) == 0:
#         return ""
#     return "  (" + " | ".join(opts) + ")"
# endglobal


# snippet al "always/always_comb/always_ff/always_latch"
# always$1`!p snip.rv = complete( t[1], ['_comb', '_ff', '_latch'] )`
# endsnippet

# # pre_expand "snip.buffer[snip.line] = 'always'; snip.cursor.preserve()"
# snippet always "always @( posedge clock ) .."
# always @(${1:posedge clock}${2: or negedge reset}) begin
#   ${0}
# end
# endsnippet

# let-heredoc {{{1

snippet let-heredoc "" bm
let ${1:var} =<< ${2:trim }$3`!p snip.rv = complete(t[3], ['END', 'EOF'])`
$0
$3
endsnippet

# regular mapping {{{1

# TODO:
# We should add `<unique>`, but maybe only for non-plug mappings?
# And only in a plugin file (not in vimrc or temp file)?
snippet map "regular mapping" bm
nno `!v
expand('%:p:h:t') is# 'ftplugin' ? '<buffer><nowait><silent>' : '<silent>'
` ${1:cd} :<c-u>call $2`!p
snip.rv = complete(t[2], ['<sid>func', 'Func'])
`()<cr>
$0
endsnippet

# plug mapping {{{1

# When you perform a substitution in a mirror, you use the python regex engine.
# The latter is different than the one in VimL:
#
#    - to get a non-greedy quantifier, you must suffix it with `?`
#    - in the replacement part, $123 matches the 123th capturing group

snippet mp "plug mapping" bm
nmap <unique> ${1:lhs} <plug>(${2:plugin_function})
nno <silent> <plug>($2) :<c-u>call ${2/(.*?)_(.*)/$1#$2/}()<cr>
$0
endsnippet

# user mapping {{{1

snippet mu "Install user-respectful mappings" bm
if empty(mapcheck('${1:key}', '${3:mode}')) && !hasmapto('<plug>(${2:plugin_some_func})', '$3')
	$3map <unique> $1 <plug>($2)
endif
$3no <silent> <plug>($2) :<c-u>call ${2/_/#/}()<cr>
$0
endsnippet

# q mapping {{{1

snippet mq "local mapping to end recording without closing window" bm
nno <buffer><expr><nowait><silent> q reg_recording() isnot# '' ? 'q' : ':<c-u>q<cr>'
$0
endsnippet

snippet mqq "end recording without closing window" bm
if reg_recording() isnot# ''
	return feedkeys('q', 'in')[-1]
endif
endsnippet

# op {{{1

snippet op "Custom Operator" bm
nno <silent> ${1:key} :<c-u>set opfunc=${2:function name}<cr>g@
nno <silent> $1${1/.(.*)/$1/} :<c-u>set opfunc=$2<bar>exe 'norm! '..v:count1..'g@_'<cr>
xno <silent> $1 :<c-u>call $2('vis')<cr>

com! -bar -range ${3:MyCom} call ${2/<(sid|SID)>/s:/}('Ex', <line1>, <line2>)

fu! ${2/<(sid|SID)>/s:/}(type, ...) abort
	let cb_save  = &cb
	let sel_save = &sel
	let reg_save = ['"', getreg('"'), getregtype('"')]
	try
		set cb-=unnamed cb-=unnamedplus
		set sel=inclusive

		if a:type is# 'char'
			${4:sil norm! \`[v\`]y}
		elseif a:type is# 'line'
			${5:sil norm! '[V']y}
		elseif a:type is# 'block'
			${6:sil exe "norm! \`[\<c-v>\`]y"}
		elseif a:type is# 'vis'
			${7:sil norm! gvy}
		${8:elseif a:type is# 'Ex'
			${9:sil exe a:1..','..a:2..'y'}}
		else
			return
		endif
	catch
		return lg#catch_error()
	finally
		let &cb  = cb_save
		let &sel = sel_save
		call call('setreg', reg_save)
	endtry

	$0
endfu
endsnippet

# printf {{{1

snippet printf "execute printf()" m
exe printf('$1', $0)
endsnippet

# qf title {{{1

snippet qf_title "set the title of the qf window" bm
call set$1`!p
snip.rv = complete(t[1], ['qf', 'loc'])
`list(${1/(l)|.*/(?1:0, :)/}[], 'a', {'title': '${2:my title}'})
$0
endsnippet

# Alternative:
#
#     let w:quickfix_title = '$1'
#
# Works, but only if we're inside the qf window.
#
# The previous syntax is a bit more complex, but also more flexible.
# It allows us to set the title even outside the qf window, for example inside
# a function which is building the qf list.

# restore register {{{1

snippet reg_restore "Restore the contents and type of registers" bm
call setreg('${1:z}', $1_reg, $1_type)
$0
endsnippet

# save register {{{1

snippet reg_save "Temporarily save the contents and type of registers" bm
let [ ${1:z}_reg, $1_type ] = [ getreg('$1'), getregtype('$1') ]
$0
endsnippet

# sidebar {{{1

# Why invoking `tempname()`?{{{
#
# 1. To get a unique buffer name.
#    Otherwise, if we re-invoke our code twice, we could get an issue.
#    For example, we wouldn't be able to use the same buffer name.
#    Besides, if the buffer is non-modifiable, `setline()` will fail.
#
# 2. To avoid saving the buffer in a file in the working directory by accident.
#    It shouldn't happen because of `bt=nofile`, but better be safe.
#}}}
# Why don't you execute `:setl noma ro` at the end?{{{
#
# Generally, you don't want to.
# `dirvish` doesn't do it, for example.
# It's good to be able to edit information.
#
# However, you DO need to make a buffer non-modifiable when:
#
#    - its only purpose is to be read
#
#    - it's tied to a file
#
#    - it can't be reproduced
#
#      if you edit a help file, by default, you can't undo the change
#      after restarting Vim;
#
# Those are sufficient conditions, but not necessary.
# For example, `qf` buffers are not tied to  any file, and yet they are made non
# modifiable.
# This is probably due to the qfl data structure. You shouldn't be able to change
# a qf buffer, because it could introduce a discrepancy with the qfl.
#}}}
snippet sidebar "" bm
let tempfile = tempname()..'/${1:buffer name}'
exe '$2`!p
snip.rv = complete(t[2], ['leftabove', 'topleft'])
` '.(&columns/3).'vnew '.tempfile
setl bh=delete bt=nofile nobl noswf wfw nowrap

call setline(1, ${4:put your text})

nno <buffer><expr><nowait><silent> q reg_recording() isnot# '' ? 'q' : ':<c-u>q<cr>'
$0
endsnippet

# snr {{{1

# Purpose:{{{
#
# We can call a script-local function:
#
#    - with `s:`     in its script
#    - with `<sid>`  in a mapping
#
# But there's no built-in way to call it outside of its script/mapping.
# `s:snr()` to the rescue.
#}}}
# Could we use `expand('<sfile>')` outside the function?{{{
#
# No.
# It would give  us the path to the  script file, while we want the  name of the
# function.
#}}}
# Why `.*\zs`?{{{
#
# Suppose `s:snr()` is called indirectly from another script.
# `expand('<sfile>')` will contain 2 script numbers.
#
# This is because of the call nesting.
# From `:h <sfile>`:
#
# > function call nesting is indicated like this:
# >
# >		"function {function-name1}[{lnum}]..{function-name2}[{lnum}]"
#
# You want the *last* number, because  it matches the last script-local function
# where `s:snr()` is defined.
#
# MWE:
#
#     $ cat <<'EOF' >~/.vim/autoload/script.vim
#     fu! script#echo()
#       echom 'the script number is: '. s:snr()
#     endfu
#     fu! s:snr()
#       return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze_')
#     endfu
#     EOF
#
#     $ cat <<'EOF' >/tmp/vimrc
#     fu! s:func()
#       call script#echo()
#     endfu
#     call s:func()
#     EOF
#
#     $ vim -Nu /tmp/vimrc
#     1~
#
# This output is wrong; `1` is *not* the number of `autoload/script.vim`.
# It's the number of the `vimrc`.
#}}}
snippet snr "Function to get SNR number" bm
fu! s:snr() abort
	return matchstr(expand('<sfile>'), '.*\zs<SNR>\d\+_')
endfu
$0
endsnippet

# syntax cluster, keyword, match, region {{{1

snippet sync "syntax cluster" Abm
syn cluster ${1:MyCluster} contains=${2:Group1,Group2}
$0
endsnippet

# Why don't you include the arguments `cchar` or `conceal`?{{{
#
# They are never used in the default syntax plugins:
#
#     noa vim /\<syn.*\<keyword\>.*\<\%(cchar\|conceal\)\>/gj $VIMRUNTIME/syntax/*.vim | cw
#}}}
# Why `!v ''`? It doesn't add anything!{{{
#
# It's a trick to break the snippet on several lines.
# Otherwise, it's hard to read, and it breaks the syntax highlighting in this file.
#}}}
snippet synk "syntax keyword" Abm
syn keyword ${1:xGroup} ${2:myword} `!v ''
`${3:contained }${5:containedin=${4:xContainedIn} }`!v ''
`${8:nextgroup=${6:xNextGroup} skip$7`!p
snip.rv = complete(t[7], ['white', 'nl', 'empty'])
` }${9:transparent}
$0
endsnippet

snippet synm "syntax match" Abm
syn match ${1:xGroup} ${2:excludenl }${3:keepend }/${4:pat}/ ${6:cchar=${5:❭} }${7:conceal }`!v ''
`${8:contained }${10:containedin=${9:xContainedIn} }${12:contains=${11:xContains} }`!v ''
`${13:display }${14:extend }${15:fold }${18:nextgroup=${16:xNextGroup} skip$17`!p
snip.rv = complete(t[17], ['white', 'nl', 'empty'])
` }${19:transparent}
$0
endsnippet

# Why don't you include the arguments `cchar` or `conceal`?{{{
#
# They are never used in the default syntax plugins:
#
#     noa vim /\<syn.*\<region\>.*\<\%(cchar\|conceal\)\>/gj $VIMRUNTIME/syntax/*.vim | cw
#}}}
snippet synr "syntax region" Abm
syn region ${1:xGroup} ${3:matchgroup=${2:xMatchGroup} }${4:excludenl }${5:extend }${6:keepend }`!v ''
`start=/${7:pat}/ ${9:skip=/${8:pat}/ }end=/${10:pat}/ `!v ''
`${11:concealends }${12:contained }${14:containedin=${13:xContainedIn} }${16:contains=${15:xContains} }`!v ''
`${17:display }${18:fold }${21:nextgroup=${19:xNextGroup} skip$20`!p
snip.rv = complete(t[20], ['white', 'nl', 'empty'])
` }${22:oneline }${23:transparent}
$0
endsnippet

# timer {{{1

snippet timer "immediate timer" m
call timer_start(0, {-> ${1:execute('${3:${VISUAL}}'${2:, ''})}})
$0
endsnippet

# try {{{1

snippet try "try ... catch statement" bm
try
	${1:${VISUAL}}
${5:catch${2: /^Vim\%((\a\+)\)\=:E${3:123}/}
	${4:echohl ErrorMsg
	echom v:exception
	echohl NONE}
}finally
	$0
endtry
endsnippet

# undo {{{1

pre_expand "undo_ftplugin(snip)"
snippet undo "undo filetype/indent settings" Abm
endsnippet

# vim_plug {{{1

snippet vim_plug "Vim-Plug Plugin definition" bm
Plug '$0'
endsnippet

# vimrc {{{1

# Why `after/`?{{{
#
# Necessary  if the  plugin we  want to  test has  something inside  an `after/`
# subdirectory. If we don't add it, none of its file will be sourced.
#}}}
# Why ^= instead of +=?{{{
#
# Necessary if  the plugin we  want to test  has something inside  a `ftplugin/`
# subdirectory.
#
# If we used `+=` instead, the  default filetype plugin would be sourced before,
# while it shouldn't be sourced at all (thanks to a guard).
# And if the custom ftplugin contains a  guard, it wouldn't be sourced, while it
# should.
#}}}
# Why `set rtp-=~/.vim`?{{{
#
# The next `set  rtp^=` will move `~/.vim` further away  from its original first
# position.
#
# We need to reposition it at the very beginning of the rtp.
# Otherwise,  the  interface  of  the   custom  plugin  we're  trying  to  debug
# (`~/.vim/plugged/vim-buggy-plugin/plugin`) would  be sourced before  our local
# customizations (`~/.vim/plugin/vim-buggy-plugin`).
# This could cause  an issue if our customization need to  be sourced before the
# interface.
# That's  the case  with the  `fzf.vim` plugin;  we need  this assignment  to be
# sourced before the plugin:
#
#     let g:fzf_command_prefix = 'Fz'
#
# In the past, we used this:
#
#     let &rtp = $HOME.'/.vim,'.join(filter(split(&rtp, ','), {_,v -> v isnot# $HOME.'/.vim'}), ',')
#
# But I find the current solution easier to read:
#
#     set rtp-=~/.vim
#     ...
#     set rtp^=~/.vim
#}}}
# Why `set vi=`?{{{
#
# It's equivalent to `-i NONE` on the shell command-line.
# The latter is recommended when debugging an issue.
#
# https://github.com/chrisbra/vim_faq
# /faq-2.5
#}}}
# Why `set gcr=`?{{{
#
# By default,  Neovim sets  `'gcr'`, which  makes it  send escape  sequences, to
# set  the  shape  of the  cursor;  those  are  not  understood by  our  current
# xfce4-terminal.
#
# This is  not an  issue when  we start  `$ nvim`  with `vim-term`,  because the
# latter correctly makes `'gcr'` empty when we're in xfce4-terminal.
# But it does become an issue when we start `$ nvim -Nu NONE`.
#
# Anyway, this is wrong, Neovim shouldn't do that:
# https://github.com/neovim/neovim/issues/6778#issuecomment-302945056
# }}}
snippet vimrc "Minimal vimrc to test a plugin" bm
set rtp-=~/.vim
set rtp^=~/.vim/plugged/${1:plugin}${2:
set rtp+=~/.vim/plugged/${1/$/\/after/}}
set rtp^=~/.vim/plugged/vim-debug
set rtp^=~/.vim/plugged/vim-lg-lib
set rtp^=~/.vim/plugged/vim-readline
set rtp^=~/.vim

set vi=
$3`!p
snip.rv = complete(t[3], ['set noloadplugins', 'let [g:no_plugin, g:no_after_plugin] = [1,1]'])``
!v has('nvim') ? 'set gcr=' : ''`

filetype plugin indent on
syntax enable
set wildmenu showcmd
$0
endsnippet

# while {{{1

snippet ww "while loop" Abm
let g = 0
while $1 && g < 999
	${0:${VISUAL}}
	let g += 1
endwhile
endsnippet

# window local options {{{1

snippet wlo "autocmd to set window local options" Abm
augroup my_${1:filetype}
	au! * <buffer>
	au BufWinEnter  <buffer>  setl ${2:fdm=marker}
	$0
augroup END
endsnippet
